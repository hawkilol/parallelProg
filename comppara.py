# -*- coding: utf-8 -*-
"""compPara.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ePdBBXZDczICaU_SU5iSztbnhg0DrLHl
"""

!apt list --installed

!nvcc --version

code = """
// OpenMP program to print Hello World
// using C language

// OpenMP header
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{

    // Beginning of parallel region
    #pragma omp parallel
    {
        printf("Hello World... from thread = %d \\n", omp_get_thread_num());
    }
    // Ending of parallel region
}
"""

code = """
// OpenMP program to print Hello World
// using C language

// OpenMP header

#include <omp.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{

    #pragma omp parallel num_threads(4)
    {
      int id = omp_get_thread_num();
      int num_threads = omp_get_num_threads();

      if(id == 0){
        printf("Estou atrasada para a barreira ! Tecle enter \\n ");
        getchar();
      }
      #pragma omp barrier
        printf("Cheguei na barreira. Eu sou a %d de %d threads \\n", id, num_threads);
    }
    return 0;
}
"""

code = """
// OpenMP program to print Hello World
// using C language

// OpenMP header

#include <omp.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
  int a, i, n=5, b[n];
  #pragma omp parallel shared(a,b) private(i)
  {
    #pragma omp master
    {
      a = 10;
      printf("Construtor master é executado pela thread %d\\n", omp_get_thread_num());
    }
    #pragma omp barrier

    #pragma omp for
      for(i = 0; i < n; i++)
        b[i] = a;


  }
      printf("Apos a regiao paralela: \\n");
      for(i =0; i < n ; i++)
        printf("b[%d] = %d\\n", i, b[i]);
}
"""

#atomic

text_file = open("code.c", "w")
text_file.write(code)
text_file.close()



#Useful
#gcc –g –fopenmp -o progT progT.c
#./progT

#gcc –g –fopenmp -o progT progT.c
#OMP_NUM_THREADS=6 ./progT

#omp_set_num_threads (4);

#gcc –o primos prog_omp_Numeros_Primos.c –fopenmp –O3 –std=c11 –lm
#./primos 5000000
####
# "-O3" is an optimization flag that instructs the compiler to perform aggressive code optimization at the highest level. This optimization level can improve the execution speed of the resulting program but may also increase the compilation time.
# "-std=c11" specifies the C programming language standard to be used during compilation. In this case, it indicates the C11 standard, which is the 2011 version of the C language standard.
# "-lm" is a linker flag that instructs the compiler to link the math library ("-l" indicates linking and "m" refers to the math library). This library provides mathematical functions like sqrt(), sin(), cos(), etc., that you can use in your C program.
####

#export OMP_NUM_THREADS = 16

#Hello World

# Commented out IPython magic to ensure Python compatibility.
# %%writefile code.c
# // OpenMP program to print Hello World
# // using C language
# 
# // OpenMP header
# #include <omp.h>
# #include <stdio.h>
# #include <stdlib.h>
# 
# int main(int argc, char* argv[])
# {
# 
#     printf("Max Available Procs = %d\n", omp_get_num_procs());
#     printf("Max Available Threads = %d\n", omp_get_max_threads());
#     // Beginning of parallel region
#     #pragma omp parallel
#     {
#         printf("Hello World... from thread = %d \n", omp_get_thread_num());
#     }
#     // Ending of parallel region
# }

# Commented out IPython magic to ensure Python compatibility.
# %%writefile code.c
# 
# #include <omp.h>
# #include <stdio.h>
# #include <stdlib.h>
# 
# int main (int argc, char *argv[])
# {
#     printf("Max Available Procs = %d\n", omp_get_num_procs());
#     printf("Max Available Threads = %d\n", omp_get_max_threads());
#     int nthreads, tid;
# 
#     #pragma omp parallel private(nthreads, tid)
#     {
#         tid = omp_get_thread_num();
#         nthreads = omp_get_num_threads();
#         printf("Hello World Thread %d / %d\n", tid, nthreads);
# 
# 
#     }
# 
#     return 0;
# }

# Commented out IPython magic to ensure Python compatibility.
# #Threads Parallel Region
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <omp.h>
# 
# int main(int argc, char *argv[]){
#   omp_set_num_threads(4);
#   printf("Número de Threads fora da região paralela = %d\n", omp_get_num_threads());
# 
#   #pragma omp parallel
#   {
#     int nthreads, id;
#     id = omp_get_thread_num();
#     printf("Eu sou a thread = %d\n", id);
# 
#     if(id == 0){
#       nthreads = omp_get_num_threads();
#       printf("Número de Threads na região paralela = %d\n", nthreads);
#     }
# 
#   }
#   return 0;
# 
# }

# Commented out IPython magic to ensure Python compatibility.
# #For directive
# 
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <omp.h>
# #define N 20
# int main(int argc, char *argv[]){
# 
#   int i, n;
#   float a[N], b[N], c[N];
# 
#   for (i=0; i < N; i++){
#     a[i] = b[i] = i * 1.0;
#   }
#   n = N;
# 
#   #pragma omp parallel num_threads(4)
#   {
#     int id = omp_get_thread_num();
#     #pragma omp for
#     for (i=0; i < n; i++) {
#         c[i] = a[i] + b[i];
#         printf("thread %d executa a iteração %d do loop\n", id, i);
#     }
#   }
# 
# 
# 
# 
# }

# Commented out IPython magic to ensure Python compatibility.
# # Sections
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <omp.h>
# int main(int argc, char *argv[])
# {
#     int secao = 0;
# 
#     #pragma omp parallel sections
#     {
#         #pragma omp section
#         {
#             int id = omp_get_threads_num();
#             secao++;
#             printf("Ordem de execução da sessão %d, thread %d\n", secao, id);
#         }
# 
#         #pragma omp section
#         {
#             int id = omp_get_thread_num();
#             secao++;
#             printf("Ordem de execução da sessão %d, thread %d\n", secao, id);
#         }
#     }
# }

# Commented out IPython magic to ensure Python compatibility.
# # Single
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <omp.h>
# #define N 20
# 
# int main(int argc, char *argv[])
# {
#     float a[N], b[N], c[N];
#     #pragma omp parallel
#         #pragma omp single
#         printf("Inicio da região paralela número de threads = % d\n", omp_get_thread_num());
#         #pragma omp for
#         for (int i = 0; i < N; i++)
#         {
#             c[i] = a[i] + b[i];
#             printf("Thread % d executa a iteração % d do loop\n", omp_get_thread_num(), i);
#         }
# 
# }

# Commented out IPython magic to ensure Python compatibility.
# # Sections task
# %%writefile code.c
# 
# #include <stdio.h>
# #include <omp.h>
# #include <stdlib.h>
# #include <time.h>
# //Aluno: Kalil Saldanha Kaliffe // 202004940030
# int main () {
# 
# 	int arr1[10], arr2[10], arrSum[10], arrSum1[10], arrSub[10];
# 	int nthreads, tid, tidSec1, tidSec2;
# 	nthreads = omp_get_num_threads();
# 	for(int i = 0; i < 10; i++){
# 		arr1[i] = i + rand() % 24;
# 		arr2[i] = i + rand() % 24;
# 	}
# 
# 	#pragma omp parallel
# 	{
# 		tid = omp_get_thread_num();
# 		#pragma omp for
# 		for(int i = 0; i < 10; i++){
# 
# 			arrSum[i] = arr1[i] + arr2[i];
# 			printf("\nArr soma Id Thread: %d / %d - Iteracao: %d - valor calc: %d \n", tid, nthreads, i, arrSum[i]);
# 
# 		}
# 	}
# 	#pragma omp parallel sections
# 	{
# 
# 		#pragma omp section
# 		{
# 	    tidSec1 = omp_get_thread_num();
# 		for(int i = 0; i < 10; i++){
# 
# 			arrSum1[i] = arr1[i] + arr2[i];
# 			printf("\nArr soma - Id Thread: %d / %d - Iteracao: %d - valor calc: %d \n", tid, nthreads, i, arrSum1[i]);
# 
# 		}
# 		}
# 
# 		#pragma omp section
# 		{
# 	    tidSec2 = omp_get_thread_num();
# 		for(int i = 0; i < 10; i++){
# 
# 			arrSub[i] = arr1[i] - arr2[i];
# 			printf("\nArr Subtracao - Id Thread: %d / %d - Iteracao: %d - valor calc: %d \n", tid, nthreads, i, arrSub[i]);
# 
# 		}
# 		}
# 
# 	}
# 
# 	printf("\n Fim do programa \n");
# 
# 
# 	return 0;
# 
# }

# Commented out IPython magic to ensure Python compatibility.
# # Barrier
# %%writefile code.c
# 
# #include <omp.h>
# #include <stdio.h>
# #include <stdlib.h>
# 
# int main(int argc, char* argv[])
# {
# 
#     #pragma omp parallel num_threads(4)
#     {
#       int id = omp_get_thread_num();
#       int num_threads = omp_get_num_threads();
# 
#       if(id == 0){
#         printf("Estou atrasada para a barreira ! Tecle enter \\n ");
#         getchar();
#       }
#       #pragma omp barrier
#         printf("Cheguei na barreira. Eu sou a %d de %d threads \\n", id, num_threads);
#     }
#     return 0;
# }

# Commented out IPython magic to ensure Python compatibility.
# # Master
# %%writefile code.c
# #include <omp.h>
# #include <stdio.h>
# #include <stdlib.h>
# 
# int main(int argc, char* argv[])
# {
#   int a, i, n=5, b[n];
#   #pragma omp parallel shared(a,b) private(i)
#   {
#     #pragma omp master
#     {
#       a = 10;
#       printf("Construtor master é executado pela thread %d\n", omp_get_thread_num());
#     }
#     #pragma omp barrier
# 
#     #pragma omp for
#       for(i = 0; i < n; i++)
#         b[i] = a;
# 
# 
#   }
#       printf("Apos a regiao paralela: \n");
#       for(i =0; i < n ; i++)
#         printf("b[%d] = %d\n", i, b[i]);
# }

# Commented out IPython magic to ensure Python compatibility.
# # Critical
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <omp.h>
# #define N 5
# 
# int main(int argc, char *argv[])
# {
#     int i, id, n;
#     float a[N];
#     float sum = 0.0, sumLocal = 0.0;
# 
#     for (i=0; i < N; i++) {
#         a[i] = i*1.0;
#     }
#     n = N;
# 
#     #pragma omp parallel shared(n,sum) private(id,sumLocal)
#     {
#         id = omp_get_thread_num();
# 
#         #pragma omp of
#         for (i=0; i < n; i++) {
#             sumLocal += a[i];
#         }
# 
#         #pragma omp critical(soma_local)
#         {
#             sum += sumLocal;
#             printf("Id = %d: sumLocal = %f: sum = %f:\n", id, sumLocal, sum);
# 
#         }
#     }
#     printf("Valor da soma após a região paralela: %f\n", sum);
# }

# Commented out IPython magic to ensure Python compatibility.
# # Atomic
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <omp.h>
# #define N 5
# 
# int main(int argc, char *argv[])
# {
#     int i, id, n;
#     float a[N];
#     float sum = 0.0, sumLocal = 0.0;
# 
#     for (i=0; i < N; i++) {
#         a[i] = i*1.0;
#     }
#     n = N;
# 
#     #pragma omp parallel shared(n,sum) private(id,sumLocal)
#     {
#         id = omp_get_thread_num();
# 
#         #pragma omp of
#         for (i=0; i < n; i++) {
#             sumLocal += a[i];
#         }
# 
#         #pragma omp atomic update
# 
#             sum += sumLocal;
#             printf("Id = %d: sumLocal = %f: sum = %f:\n", id, sumLocal, sum);
# 
# 
#     }
#     printf("Valor da soma após a região paralela: %f\n", sum);
# }

# 1. #pragma omp parallel shared (a,b,c,n) private (id,i) {
# 2. #pragma omp for
# 3. for (i = 0; i < n; i++) {
# 4. id = omp_get_thread_num();
# 5. c[i] = a[i] + b[i];
# 6. printf(“Thread %d executa a iteração %d do
# 7. loop\n”, id,i);
# 8. }
# 9. }

# 1. double media = 0.0f, A[N]; int i;
# 2. #pragma omp parallel for reduction (+:media)
# 3. for (i = 0; i < N; i++) {
# 4. media += A[i];
# 5. }
# 6. media = media/N;

# Commented out IPython magic to ensure Python compatibility.
# # Reduction
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <omp.h>
# #define SOMA_INICIAL 1000
# 
# int main(int argc, char *argv[])
# {
#     int i, n = 25;
#     int a[n], soma;
#     int ref = SOMA_INICIAL + ((n-1)*n)/2;
# 
#     omp_set_num_threads (4);
# 
#     for (i=0; i < n; i++){
#         a[i] = i;
#     }
#         soma = SOMA_INICIAL;
#         printf("Valor da soma antes da região paralela: %d\n", soma);
# 
#     #pragma omp parallel default(none) shared(n,a) reduction(+:soma)
#     {
#         soma = 0;
# 
#         #pragma omp for
#             for (i=0; i < n; i++) {
#                 soma += a[i];
#             }
#             printf("Valor Soma na Threads:%d é igual %d\n", omp_get_thread_num(), soma);
# 
#     }
#     printf("Valor da Soma Depois da Região Paralela: %d\n", soma);
#     printf("Verificação do Resultado: soma %d (deveria ser %d)\n", soma, ref);
# }

# Commented out IPython magic to ensure Python compatibility.
# # Case Study: Counting Prime Numbers
# %%writefile primos.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <math.h>
# #include <omp.h>
# #define SOMA_INICIAL 1000
# 
# int primo (long int n) {
#     long int i;
# 
#     for (i = 3; i < (sqrt(n) + 1); i+=2) {
#         if (n%i == 0) {
#             return 0;
#         }
#         printf("Primo! -> %ld\n", n);
#         return 1;
#     }
# }
# 
# int main(int argc, char *argv[])
# {
#    double t_inicio, t_fim;
#    long int i, n, total;
#     if (argc < 2) {
#         printf("Valor inválido! Entre com o valor do maior inteiro\n");
#         return 0;
#     }
#     else {
#         n = strtol(argv[1], (char **) NULL, 10);
#     }
#     total = 0;
#     t_inicio = omp_get_wtime();
# 
#     #pragma omp parallel for reduction(+:total) schedule(static)
#         for (i = 3; i <= n; i += 2) {
#             if (primo(i) == 1) {
#                 total++;
#             }
#         }
#         total += 1;
#     t_fim = omp_get_wtime();
#     printf("Quantidade de Primos entre 1 e %ld: %ld\n", n, total);
#     printf("Tempo de execução: %f com %d threads\n", (t_fim - t_inicio), omp_get_max_threads());
# 
#     return 0;
# }
# 
#

!gcc -o primos primos.c -fopenmp -O3 -std=c11 -lm
!./primos 5000



# Commented out IPython magic to ensure Python compatibility.
# #Time Routine Test
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <math.h>
# #include <omp.h>
# #define N 10000
# 
# int main(int argc, char *argv[])
# {
#     int i, n;
#     float a[N], b[N], c[N];
#     double inicio, fim;
# 
#     inicio = omp_get_wtime();
# 
#     for (i=0; i < N; i++) {
#         a[i] = b[i] = i * 1.0;
#     }
#     n = N;
# 
#     #pragma omp parallel num_threads(4)
#     {
#         int id = omp_get_thread_num();
# 
#         if (id == 0) {
#             int num_procs = omp_get_num_procs();
#             int max_threads = omp_get_max_threads();
#             printf("Número de processadores disponíveis = %d\n", num_procs);
#             printf("Número Máximo de Threads = %d\n", max_threads);
#         }
#         #pragma omp for
#         for (i=0; i < n; i++) {
#             c[i] = a[i] + b[i];
#             printf("Thread %d executa a iteração %d do loop com valor %f\n", id, i, c[i]);
#         }
#     }
#     fim = omp_get_wtime();
#     printf("Tempo de Execução = %3.4f segundos\n", fim - inicio);
#     printf("Precisão do Relógio = %3.9f segundos\n", omp_get_wtick());
# 
# }
# 
# 
#

# Commented out IPython magic to ensure Python compatibility.
# # Schedule
# %%writefile code.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <omp.h>
# #define N 10000
# 
# int main(int argc, char *argv[])
# {
#     printf("Max Available Procs = %d\n", omp_get_num_procs());
#     printf("Max Available Threads = %d\n", omp_get_max_threads());
#     int i, n = 20;
#     printf("Cláusula static SEM o parâmetro tam\n");
# 
#     #pragma omp parallel for schedule (static) num_threads (4)
#     for (i = 0; i < n; ++i) {
#         printf("ID = %d iteração = %d\n", omp_get_thread_num(), i);
#     }
#     printf("Cláusula static COM o parâmetro tam\n");
# 
#     #pragma omp parallel for schedule (static,3) num_threads (4)
#         for (i = 0; i < n; i++) {
#             printf("ID = %d iteração = %d\n", omp_get_thread_num(),i);
#         }
#     return 0;
# }
# 
# 
#

# Commented out IPython magic to ensure Python compatibility.
# %env OMP_NUM_THREADS=

!nvcc --version

!gcc -o hello -fopenmp code.c
# with math.h #gcc –o primos prog_omp_Numeros_Primos.c –fopenmp –O3 –std=c11 –lm
#./primos 5000000

!./hello